{
    "collab_server" : "",
    "contents" : "### Version Periodic (Sampling To Sampling) Datasets\n#\n# Created: 09/06/2016\n# Last Modified: 31/08/2016\n#\n# Author: Gerasimos Antzoulatos (i2s)\n#\n# This is the server logic for a Shiny web application.\n\n#---------------------------------------------------------------------------------- shinyServer.......\n#\nshinyServer(function(input, output, session){\n  \n  #---------------------------------------------------------------------------------------------------\n  #     Import the Dataset \n  #---------------------------------------------------------------------------------------------------\n  Inpt.Dataset <- reactive({ \n\n    inFile <- input$file\n    \n    if (is.null(inFile)){\n       return(NULL)\n    }\n    \n    # Read from the input file\n    newpath.filename <- paste(inFile$datapath, input$ext, sep=\".\")\n    file.rename(inFile$datapath, newpath.filename)\n    if ( input$ext == 'csv' )\n    {\n        dset <- read.csv(newpath.filename, header = input$header, sep = ';', dec = '.')\n    }\n    else{\n        dset <- read_excel(newpath.filename, sheet = 1, col_names = input$header)\n    }\n    \n    new.names <- names(dset)\n    new.names <- gsub(\"[:(:]No[:):]\", \"No\", new.names)\n    new.names <- gsub(\"[:(:]Kg[:):]\", \"Kg\", new.names)\n    new.names <- gsub(\"[:(:][:%:][:):]\", \"Perc\", new.names)\n    new.names <- gsub(\"[:%:]\", \"Perc\", new.names)\n    new.names <- gsub(\"[:(:]Kg [:/:] Hour[:):]\",\"Kg.per.Hour\", new.names)\n    new.names <- gsub(\"[:+:]\",\"Plus\", new.names)\n    new.names <- gsub(\"-\", \"Minus\", new.names, fixed=TRUE)\n    new.names <- gsub(\" \", \".\",new.names)\n    new.names <- gsub(\"..\", \".\", new.names, fixed=TRUE)\n    new.names <- gsub(\"_\", \".\", new.names, fixed=TRUE)\n    \n    colnames(dset) <- new.names\n    data <- create.dataset(dset)\n \n    write.csv(data, file = \"MyData.csv\",row.names=FALSE, sep=\";\", col.names = TRUE)\n    \n    return(data)\n    \n  })\n  \n  #---------------------------------------------------------------------------------------------------\n  #     Subset of Dataset\n  #---------------------------------------------------------------------------------------------------\n  passDataDim <- reactive({\n    \n    data <- Inpt.Dataset()\n    \n    if (input$dimRegion != \"All\"){\n      data <- subset(data, Region %in% c(input$dimRegion))\n    }\n    if (input$dimSpecies != \"All\"){\n      data <- subset(data, Species %in% c(input$dimSpecies))\n    }\n    if (input$dimSite != \"All\"){\n      data <- subset(data, Site %in% c(input$dimSite))\n    }\n    if (input$dimBatch != \"All\"){\n      data <- subset(data, Batch %in% c(input$dimBatch))\n    }\n    if (input$dimUnit != \"All\"){\n      data <- subset(data, Unit %in% c(input$dimUnit))\n    }\n    if (input$dimHatchery != \"All\"){\n      data <- subset(data, Hatchery %in% c(input$dimHatchery))\n    }\n    if (input$dimOriginMonth != \"All\"){\n      data <- subset(data, Origin.Month %in% c(input$dimOriginMonth))\n    }\n    if (input$dimOriginYear != \"All\"){\n      data <- subset(data, Origin.Year %in% c(input$dimOriginYear))\n    }\n    if (input$dimSamplMonth != \"All\"){\n      data <- subset(data, From.Month %in% c(input$dimSamplMonth))\n    }\n    if (input$dimSamplYear != \"All\"){\n      data <- subset(data, From.Year %in% c(input$dimSamplYear))\n    }\n    if (input$dimActualFeed != \"All\"){\n      data <- subset(data, Actual.Feed %in% c(input$dimActualFeed))\n    }\n    if (input$dimFeedCategory != \"All\"){\n      data <- subset(data, Feed.Category %in% c(input$dimFeedCategory))\n    }\n    if (input$dimSupplier != \"All\"){\n      data <- subset(data, Supplier %in% c(input$dimSupplier))\n    }\n    if (input$dimFeedingPolicy != \"All\"){\n      data <- subset(data, Feeding.Policy %in% c(input$dimFeedingPolicy))\n    }\n    if (input$dimStartAvWtCat != \"All\"){\n      data <- subset(data, Start.Av.Weight.Category %in% c(input$dimStartAvWtCat))\n    }\n    if (input$dimEndAvWtCat != \"All\"){\n      data <- subset(data, End.Av.Weight.Category %in% c(input$dimEndAvWtCat))\n    }\n    \n    return(data)\n  })\n  \n  #----------------------------\n  passData <- reactive({\n\n    data <- Inpt.Dataset()\n    \n    if (input$dimRegion != \"All\"){\n      data <- subset(data, Region %in% c(input$dimRegion))\n    }\n    if (input$dimSpecies != \"All\"){\n      data <- subset(data, Species %in% c(input$dimSpecies))\n    }\n    if (input$dimSite != \"All\"){\n      data <- subset(data, Site %in% c(input$dimSite))\n    }\n    if (input$dimBatch != \"All\"){\n      data <- subset(data, Batch %in% c(input$dimBatch))\n    }\n    if (input$dimUnit != \"All\"){\n      data <- subset(data, Unit %in% c(input$dimUnit))\n    }\n    if (input$dimHatchery != \"All\"){\n      data <- subset(data, Hatchery %in% c(input$dimHatchery))\n    }\n    if (input$dimOriginMonth != \"All\"){\n      data <- subset(data, Origin.Month %in% c(input$dimOriginMonth))\n    }\n    if (input$dimOriginYear != \"All\"){\n      data <- subset(data, Origin.Year %in% c(input$dimOriginYear))\n    }\n    if (input$dimSamplMonth != \"All\"){\n      data <- subset(data, From.Month %in% c(input$dimSamplMonth))\n    }\n    if (input$dimSamplYear != \"All\"){\n      data <- subset(data, From.Year %in% c(input$dimSamplYear))\n    }\n    if (input$dimActualFeed != \"All\"){\n      data <- subset(data, Actual.Feed %in% c(input$dimActualFeed))\n    }\n    if (input$dimFeedCategory != \"All\"){\n      data <- subset(data, Feed.Category %in% c(input$dimFeedCategory))\n    }\n    if (input$dimFeedingPolicy != \"All\"){\n      data <- subset(data, Feeding.Policy %in% c(input$dimFeedingPolicy))\n    }\n    if (input$dimSupplier != \"All\"){\n      data <- subset(data, Supplier %in% c(input$dimSupplier))\n    }\n    if (input$dimStartAvWtCat != \"All\"){\n      data <- subset(data, Start.Av.Weight.Category %in% c(input$dimStartAvWtCat))\n    }\n    if (input$dimEndAvWtCat != \"All\"){\n      data <- subset(data, End.Av.Weight.Category %in% c(input$dimEndAvWtCat))\n    }\n  \n    data <- data[ data$Start.Av.Weight >= as.numeric(input$rangeStAvWeight[1]) &\n                  data$Start.Av.Weight <= as.numeric(input$rangeStAvWeight[2]) &\n                  data$End.Av.Weight >= as.numeric(input$rangeEndAvWeight[1]) &\n                  data$End.Av.Weight <= as.numeric(input$rangeEndAvWeight[2]) &\n                  data$Econ.FCR.Period >= as.numeric(input$rangeEconPeriodFCR[1]) &\n                  data$Econ.FCR.Period <= as.numeric(input$rangeEconPeriodFCR[2]) &\n                  data$Biol.FCR.Period >= as.numeric(input$rangeBiolPeriodFCR[1]) &\n                  data$Biol.FCR.Period <= as.numeric(input$rangeBiolPeriodFCR[2]) &\n                  data$SGR.Period.Perc >= as.numeric(input$rangePeriodSGR[1]) &\n                  data$SGR.Period.Perc <= as.numeric(input$rangePeriodSGR[2]) &\n                  data$SFR.Period.Perc >= as.numeric(input$rangePeriodSFR[1]) &\n                  data$SFR.Period.Perc <= as.numeric(input$rangePeriodSFR[2]) &\n                  data$TGC.Period >= as.numeric(input$rangePeriodTGC[1]) &\n                  data$TGC.Period <= as.numeric(input$rangePeriodTGC[2]) &\n                  data$Growth.Per.Day >= as.numeric(input$rangeGrowthPerDay[1]) &\n                  data$Growth.Per.Day <= as.numeric(input$rangeGrowthPerDay[2]) &\n                  data$Mortality.Perc >= as.numeric(input$rangePeriodMortalityPerc[1]) &\n                  data$Mortality.Perc <= as.numeric(input$rangePeriodMortalityPerc[2]) &\n                  data$Diff.Days >= as.numeric(input$rangeDiffDays[1]) &\n                  data$Diff.Days <= as.numeric(input$rangeDiffDays[2]) &\n                  data$Period.Day.Degrees >= as.numeric(input$rangePeriodDayDegrees[1]) &\n                  data$Period.Day.Degrees <= as.numeric(input$rangePeriodDayDegrees[2]) &\n                  data$Av.Wt.Deviation.Perc >= as.numeric(input$rangeAvWtDeviation[1]) &\n                  data$Av.Wt.Deviation.Perc <= as.numeric(input$rangeAvWtDeviation[2]) &\n                  data$Feed.Deviation.Perc  >= as.numeric(input$rangeFeedDeviation[1]) &\n                  data$Feed.Deviation.Perc  <= as.numeric(input$rangeFeedDeviation[2]) & \n                  data$Avg.Temp >= as.numeric(input$rangeAvgTemp[1]) &\n                  data$Avg.Temp <= as.numeric(input$rangeAvgTemp[2]) &\n                  data$LTD.Econ.FCR >= as.numeric(input$rangeLTDEconFCR[1]) &  \n                  data$LTD.Econ.FCR <= as.numeric(input$rangeLTDEconFCR[2]) &\n                  data$LTD.Mortality.Perc >= as.numeric(input$rangeLTDMortalityPerc[1]) &  \n                  data$LTD.Mortality.Perc <= as.numeric(input$rangeLTDMortalityPerc[2]) &  \n                  (data$From >= ymd(input$dateRangeFrom[1]) & data$From <= ymd(input$dateRangeFrom[2])) & \n                  (data$To >= ymd(input$dateRangeTo[1]) & data$To <= ymd(input$dateRangeTo[2]))\n               , ] \n\n    return(data)\n  })\n  \n  #---------------------------------------------------------------------------------------------------\n  #     Download (Save) the Dataset\n  #---------------------------------------------------------------------------------------------------\n  output$downloadData <- downloadHandler(\n    \n      # This function returns a string which tells the client\n      # browser what name to use when saving the file.\n      filename = function() { paste(\"New\", input$file, sep=\"_\") },\n        \n      # This function should write data to a file given to it by\n      # the argument 'file'.\n            \n      content = function(file){\n              \n          if (input$Go.Button == 0){\n                return() }\n          else{\n              isolate({\n                datasetInput <- passData()\n                fname <- paste(file,\"xlsx\",sep=\".\")\n                wb <- loadWorkbook(fname, create = TRUE)\n                createSheet(wb, name = \"Sheet1\")\n                writeWorksheet(wb, datasetInput, sheet = \"Sheet1\") # writes the data in file\n                saveWorkbook(wb)\n                file.rename(fname,file)\n              }) # end isolate\n          } # end if..else \n      } # end content\n\n  )  # end downloadHandler\n  \n  \n  #=================================================================================================\n  #   Dynamic Sidebars\n  #\n  # ---- Dimensions\n  \n  output$dimRegion <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimRegion', label='Region',\n                  choices=c(\"All\", sort(unique(as.character(data$Region)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimSpecies <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimSpecies', label='Species',\n                choices=c(\"All\", sort(unique(as.character(data$Species)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimSite <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimSite', label='Site', choices=c(\"All\", sort(unique(as.character(data$Site)))),\n                  selected=\"All\", multiple=TRUE)\n  })\n  output$dimUnit <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimUnit', label='Unit', choices=c(\"All\", sort(unique(as.character(data$Unit)))),\n                  selected=\"All\", multiple=TRUE)\n  })\n  output$dimBatch <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimBatch', label='Batch', choices=c(\"All\", sort(unique(as.character(data$Batch)))),\n                  selected=\"All\", multiple=TRUE)\n  })\n  output$dimHatchery <- renderUI({\n      data <- Inpt.Dataset()\n      selectInput(inputId='dimHatchery', label='Hatchery', choices=c(\"All\", sort(unique(as.character(data$Hatchery)))),\n                  selected=\"All\", multiple=TRUE)\n  })\n  output$dimOriginMonth <- renderUI({\n    data <- Inpt.Dataset()\n    origin.months <- factor(unique(as.character(data$Origin.Month)), levels = month.name)\n    selectInput(inputId='dimOriginMonth', label='Origin.Month',\n                choices=c(\"All\", levels(origin.months)), selected=\"All\", multiple=TRUE)\n  })\n  output$dimOriginYear <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimOriginYear', label='Origin.Year',\n                choices=c(\"All\", sort(unique(as.character(data$Origin.Year)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimSamplMonth <- renderUI({\n    data <- Inpt.Dataset()\n    from.months <- factor(unique(as.character(data$From.Month)), levels = month.name)\n    selectInput(inputId='dimSamplMonth', label='Sampling.Month',\n                choices=c(\"All\", levels(from.months)), selected=\"All\", multiple=TRUE)\n  })\n  output$dimSamplYear <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimSamplYear', label='Sampling.Year',\n                choices=c(\"All\", sort(unique(as.character(data$From.Year)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimActualFeed <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimActualFeed', label='Actual.Feed',\n                choices=c(\"All\", sort(unique(as.character(data$Actual.Feed)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimFeedCategory <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimFeedCategory', label='Feed.Category',\n                choices=c(\"All\", sort(unique(as.character(data$Feed.Category)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimFeedingPolicy <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimFeedingPolicy', label='Feeding.Policy',\n                choices=c(\"All\", sort(unique(as.character(data$Feeding.Policy)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimSupplier <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimSupplier', label='Supplier',\n                choices=c(\"All\", sort(unique(as.character(data$Supplier)))), selected=\"All\", multiple=TRUE)\n  })\n  output$dimStartAvWtCat <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimStartAvWtCat', label='Start.Av.Weight.Category',\n                choices=c(\"All\", sort(unique(as.character(data$'Start.Av.Weight.Category')))), \n                      selected=\"All\", multiple=TRUE)\n  })\n  output$dimEndAvWtCat <- renderUI({\n    data <- Inpt.Dataset()\n    selectInput(inputId='dimEndAvWtCat', label='End.Av.Weight.Category',\n                choices=c(\"All\", sort(unique(as.character(data$'End.Av.Weight.Category')))), \n                selected=\"All\", multiple=TRUE)\n  })\n  output$dateRangeFrom <- renderUI({\n    data <- Inpt.Dataset()\n    dateRangeInput('dateRangeFrom',\n                   label = paste(' Start Date (From): '),\n                   start = min( ymd(data$From)-days(0) ), \n                   end = max( ymd(data$From)+days(1) ),\n                   min = min( ymd(data$From)-days(0) ),\n                   max = max( ymd(data$From)+days(1)),\n                   separator = \" to \", format = \"dd/mm/yyyy\",\n                   startview = 'year', language = 'en', weekstart = 0\n    )\n  })\n  output$dateRangeTo <- renderUI({\n    data <- Inpt.Dataset()\n    dateRangeInput('dateRangeTo',\n                   label = paste(' End Date (To): '),\n                   start = min( ymd(data$To)-days(1) ), \n                   end = max( ymd(data$To)+days(1) ),\n                   min = min( ymd(data$To)-days(1) ),\n                   max = max( ymd(data$To)+days(1) ),\n                   separator = \" to \", format = \"dd/mm/yyyy\",\n                   startview = 'year', language = 'en', weekstart = 0\n    )\n  })\n  # ---- Measures\n   output$rangeStAvWeight  <- renderUI({\n     data <- passDataDim()\n     sliderInput(\"rangeStAvWeight\", \"Start.Av.Weight:\",\n                 min = min(as.double(data$Start.Av.Weight), na.rm=TRUE),\n                 max = max(as.double(data$Start.Av.Weight), na.rm=TRUE),\n                 value = c(min(as.double(data$Start.Av.Weight), na.rm=TRUE),\n                           max(as.double(data$Start.Av.Weight), na.rm=TRUE)),\n                 step=1, round=-2)\n   })\n   output$rangeEndAvWeight  <- renderUI({    \n     data <- passDataDim()  \n     sliderInput(\"rangeEndAvWeight\", \"End.Av.Weight:\",\n                  min = min(as.double(data$End.Av.Weight), na.rm=TRUE),\n                  max = max(as.double(data$End.Av.Weight), na.rm=TRUE),\n                  value = c(min(as.double(data$End.Av.Weight), na.rm=TRUE),\n                            max(as.double(data$End.Av.Weight), na.rm=TRUE)),\n                  step=1, round=-2)\n   })\n   output$rangeEconPeriodFCR <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeEconPeriodFCR\", \"Econ.FCR.Period:\",\n                 min = min(as.double(data$Econ.FCR.Period), na.rm=TRUE),\n                 max = max(as.double(data$Econ.FCR.Period), na.rm=TRUE),\n                 value = c(min(as.double(data$Econ.FCR.Period), na.rm=TRUE),\n                           max(as.double(data$Econ.FCR.Period), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangeBiolPeriodFCR <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeBiolPeriodFCR\", \"Biol.FCR.Period:\",\n                 min = min(as.double(data$Biol.FCR.Period), na.rm=TRUE),\n                 max = max(as.double(data$Biol.FCR.Period), na.rm=TRUE),\n                 value = c(min(as.double(data$Biol.FCR.Period), na.rm=TRUE),\n                           max(as.double(data$Biol.FCR.Period), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangePeriodSGR  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangePeriodSGR\", \"SGR.Period.Perc:\",\n                 min = min(as.double(data$SGR.Period.Perc), na.rm=TRUE),\n                 max = max(as.double(data$SGR.Period.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$SGR.Period.Perc), na.rm=TRUE),\n                           max(as.double(data$SGR.Period.Perc), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangePeriodSFR  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangePeriodSFR\", \"SFR.Period.Perc:\",\n                 min = min(as.double(data$SFR.Period.Perc), na.rm=TRUE),\n                 max = max(as.double(data$SFR.Period.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$SFR.Period.Perc), na.rm=TRUE),\n                           max(as.double(data$SFR.Period.Perc), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangePeriodTGC  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangePeriodTGC\", \"TGC.Period:\",\n                 min = min(as.double(data$TGC.Period), na.rm=TRUE),\n                 max = max(as.double(data$TGC.Period), na.rm=TRUE),\n                 value = c(min(as.double(data$TGC.Period), na.rm=TRUE),\n                           max(as.double(data$TGC.Period), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangeGrowthPerDay  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeGrowthPerDay\", \"Growth.Per.Day:\",\n                 min = min(as.double(data$Growth.Per.Day), na.rm=TRUE),\n                 max = max(as.double(data$Growth.Per.Day), na.rm=TRUE),\n                 value = c(min(as.double(data$Growth.Per.Day), na.rm=TRUE),\n                           max(as.double(data$Growth.Per.Day), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangePeriodMortalityPerc  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangePeriodMortalityPerc\", \"Mortality.Perc:\",\n                 min = min(as.double(data$Mortality.Perc), na.rm=TRUE),\n                 max = max(as.double(data$Mortality.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$Mortality.Perc), na.rm=TRUE),\n                           max(as.double(data$Mortality.Perc), na.rm=TRUE)),\n                 step=0.1, round=-2)\n  })\n  output$rangeDiffDays  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeDiffDays\", \"Diff.Days:\",\n                 min = min(as.double(data$Diff.Days), na.rm=TRUE),\n                 max = max(as.double(data$Diff.Days), na.rm=TRUE),\n                 value = c(min(as.double(data$Diff.Days), na.rm=TRUE),\n                           max(as.double(data$Diff.Days), na.rm=TRUE)),\n                 step=1, round=-2)\n   })\n   output$rangePeriodDayDegrees  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangePeriodDayDegrees\", \"Period.Day.Degrees:\",\n                 min = min(as.double(data$Period.Day.Degrees), na.rm=TRUE),\n                 max = max(as.double(data$Period.Day.Degrees), na.rm=TRUE),\n                 value = c(min(as.double(data$Period.Day.Degrees), na.rm=TRUE),\n                           max(as.double(data$Period.Day.Degrees), na.rm=TRUE)),\n                 step=10, round=-2)\n   })\n   output$rangeAvWtDeviation  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeAvWtDeviation\", \"Av.Wt.Deviation.Perc:\",\n                 min = min(as.double(data$Av.Wt.Deviation.Perc), na.rm=TRUE),\n                 max = max(as.double(data$Av.Wt.Deviation.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$Av.Wt.Deviation.Perc), na.rm=TRUE),\n                           max(as.double(data$Av.Wt.Deviation.Perc), na.rm=TRUE)),\n                 step=0.5, round=-2)\n   })\n   output$rangeFeedDeviation  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeFeedDeviation\", \"Feed.Deviation.Perc:\",\n                 min = min(as.double(data$Feed.Deviation.Perc), na.rm=TRUE),\n                 max = max(as.double(data$Feed.Deviation.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$Feed.Deviation.Perc), na.rm=TRUE),\n                           max(as.double(data$Feed.Deviation.Perc), na.rm=TRUE)),\n                 step=0.5, round=-2)\n   })\n   output$rangeAvgTemp  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeAvgTemp\", \"Avg.Temp:\",\n                 min = min(as.double(data$Avg.Temp), na.rm=TRUE),\n                 max = max(as.double(data$Avg.Temp), na.rm=TRUE),\n                 value = c(min(as.double(data$Avg.Temp), na.rm=TRUE),\n                           max(as.double(data$Avg.Temp), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangeLTDEconFCR  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeLTDEconFCR\", \"LTD.Econ.FCR:\",\n                 min = min(as.double(data$LTD.Econ.FCR), na.rm=TRUE),\n                 max = max(as.double(data$LTD.Econ.FCR), na.rm=TRUE),\n                 value = c(min(as.double(data$LTD.Econ.FCR), na.rm=TRUE),\n                           max(as.double(data$LTD.Econ.FCR), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   output$rangeLTDMortalityPerc  <- renderUI({\n     data <- passDataDim()  \n     sliderInput(\"rangeLTDMortalityPerc\", \"LTD.Mortality.Perc:\",\n                 min = min(as.double(data$LTD.Mortality.Perc), na.rm=TRUE),\n                 max = max(as.double(data$LTD.Mortality.Perc), na.rm=TRUE),\n                 value = c(min(as.double(data$LTD.Mortality.Perc), na.rm=TRUE),\n                           max(as.double(data$LTD.Mortality.Perc), na.rm=TRUE)),\n                 step=0.1, round=-2)\n   })\n   \n   \n  #=================================================================================================\n  #\n  # Initial (0) Tab functions -- Datasets\n  #\n  #\n  output$dataset <- DT::renderDataTable({\n    if (input$action == 0){\n      return() }\n    else{ \n      isolate({\n        data <- Inpt.Dataset()\n        DT::datatable(data, class='compact', rowname = TRUE, caption=\"Dataset for processing...\",\n                      filter = 'top', extensions = 'FixedColumns',\n                      options = list(autoWidth=TRUE, scrollX = TRUE, \n                                     fixedColumns = list(leftColumns = 6)),\n                      selection = list(mode = 'multiple', target = 'row') )\n      })\n    }\n  })\n  \n  output$preproc.dataset<- DT::renderDataTable({\n    if (input$Go.Button == 0){\n      return() }\n    else{\n      isolate({\n        data <- passData()\n        DT::datatable(data, class='compact', rowname = TRUE, caption=\"Dataset after processing...\",\n                      filter = 'top', extensions = 'FixedColumns',\n                      options = list(autoWidth=TRUE, scrollX = TRUE, \n                                     fixedColumns = list(leftColumns = 6)),\n                      selection = list(mode = 'multiple', target = 'row'))\n\t\t\t\t\t  \n      })\n    }\n  })\n\n  \n  #=================================================================================================\n  #\n  # First Tab functions -- Line Plots\n  #\n  output$line.DimX <- renderUI({\n    selectInput('lineDimX', 'Dimension (X-axis):', choices=c(\"From\", \"To\"), selected = \"From\", multiple = FALSE)\n  })\n  \n  output$line.group.Batch <- renderUI({\n    data <- passData()\n    value.batch <- sort(unique(as.character(data$Batch)))\n    selectInput('linegroupBatch', 'Batch:', choices=c(\"All\", value.batch), selected = \"All\", \n                multiple = TRUE)\n  })\n  \n  output$line.group.Unit <- renderUI({\n    data <- passData()\n    if (input$linegroupBatch != \"All\"){\n      data <- subset(data, Batch %in% c(input$linegroupBatch))\n    }\n    \n    value.unit <- sort(unique(as.character(data$Unit)))\n    selectInput('linegroupUnit', 'Unit:', choices=c(\"All\", value.unit), selected = \"All\", \n                multiple = TRUE)\n  })\n  \n  output$line_plots <- renderPlotly({\n      \n    #  Re-run when button is clicked\n    # if (input$View.Lines == 0){\n    #   return() }\n    # else{\n    #   isolate({\n        \n        batch.val <- input$linegroupBatch \n        unit.val <- input$linegroupUnit\n        dim.x <- input$lineDimX\n        \n        data <- passData()\n        \n        ds <- data.frame(data$From, data$To, data$Batch, data$Unit, data$Biol.FCR.Period, data$Econ.FCR.Period, \n                         data$SFR.Period.Perc, data$SGR.Period.Perc,  data$TGC.Period)\n        colnames(ds) <- c(\"From\", \"To\", \"Batch\", \"Unit\", \"Biol.FCR.Period\", \"Econ.FCR.Period\", \"SFR.Period.Perc\", \n                          \"SGR.Period.Perc\", \"TGC.Period\")\n        \n        if ( (batch.val == \"All\") & (unit.val == \"All\") ){\n            ds <- ds[order(as.Date(ds[,dim.x])) , ]\n        }else if ( (batch.val != \"All\") & (unit.val == \"All\") ){ \n            ds <- ds[order(as.Date(ds[,dim.x])) , ] \n            ds <- subset(ds, Batch %in% c(batch.val))\n        }else if ( (unit.val != \"All\") & (batch.val == \"All\") ){ \n            ds <- ds[order(as.Date(ds[,dim.x])) , ]\n            ds <- subset(ds, Unit %in% c(unit.val))\n        }else if ( (batch.val != \"All\") & (unit.val != \"All\") ){\n            ds <- ds[order(as.Date(ds[,dim.x])) , ]\n            ds <- subset(ds, Batch %in% c(batch.val))\n        }\n      \n        p <- plot_ly(ds, x = ds[,dim.x], y = Biol.FCR.Period, mode = \"lines + markers\", name = \"Biol.FCR.Period\") %>% \n                  add_trace(x = ds[,dim.x], y = Econ.FCR.Period, name = \"Econ.FCR.Period\") %>% \n                  add_trace(x = ds[,dim.x], y = SFR.Period.Perc, name = \"SFR.Period.Perc\") %>% \n                  add_trace(x = ds[,dim.x], y = SGR.Period.Perc, name = \"SGR.Period.Perc\") %>% \n                  add_trace(x = ds[,dim.x], y = TGC.Period, name = \"TGC.Period\") %>% \n                  layout(\n                  #  title = \" Period Econ.FCR vs SFR and SGR \", \n                    xaxis = list(\n                      rangeselector = list(\n                        buttons = list(\n                          list(\n                            count = 3, \n                            label = \"3 mo\", \n                            step = \"month\",\n                            stepmode = \"backward\"),\n                          list(\n                            count = 6, \n                            label = \"6 mo\", \n                            step = \"month\",\n                            stepmode = \"backward\"),\n                          list(\n                            count = 1, \n                            label = \"1 yr\", \n                            step = \"year\",\n                            stepmode = \"backward\"),\n                          list(\n                            count = 1, \n                            label = \"YTD\", \n                            step = \"year\",\n                            stepmode = \"todate\"),\n                          list(step = \"all\"))),\n                      \n                      rangeslider = list(type = \"date\"), title=\"Date\" ),\n                    \n                    yaxis = list(title = \"KPIs\"))\n        \n          p\n        \n    #   })\n    # } \n  })   \n  \n  #=================================================================================================\n  #\n  # Second Tab functions -- Histograms\n  #\n  output$hist.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- names(data.cat) \n    selectInput('hgroup', 'Filter:', choices=c(\"None\", group.vars), multiple = FALSE)\n  })\n  #\n  output$hist.measures <- renderUI({\n    data <- passData()\n    meas.vars <- c(\"Start.Av.Weight\", \"End.Av.Weight\", \"Econ.FCR.Period\", \"Mortality.Perc\", \"Mortality.Deviation.Perc\",\n                   \"SFR.Period.Perc\", \"SGR.Period.Perc\", \"Avg.Temp\", \"Av.Wt.Deviation.Perc\", \"Diff.Days\",\n                   \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\")\n    selectInput('hmeasure', 'Measure (x-axis):', choices=meas.vars, multiple = TRUE, selected = \"Econ.FCR.Period\")\n  })\n  #\n  # output$hist_plots <- renderPlot({\n  # #  Re-run when button is clicked\n  #     if (input$View.Hist == 0){\n  #       return() }\n  #     else{\n  #       isolate({\n  #         graphData <- passData()\n  #             theGraph <- fun.histPlot(graphData,no.bins=input$numbins,meas=input$hmeasure,group_var=input$hgroup,\n  #                                     flag.facet = input$chkb.hfacet, flag.save=input$saveHPlot)\n  #         print(theGraph)\n  #       })\n  #     }\n  # })\n  \n  #------------  Multiple histograms\n  #\n  multiHistPlotsOutput <- reactive({\n    hmeas <- input$hmeasure\n    n_plot <- length(hmeas)\n\n    graphData <- passData()\n    \n    # lapply(1:n_plot, function(i){\n    #           output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlot({\n    #                     theGraph <- fun.histPlot(graphData, no.bins=input$numbins,\n    #                                              meas=hmeas[i], group_var=input$hgroup,\n    #                                              flag.facet = input$chkb.hfacet, \n    #                                              flag.save=input$saveHPlot) \n    #                     print(theGraph)\n    #           }) # end renderPlot()\n    # }) # end lapply\n    \n  #  par(mar=c(4,3,3,2), oma=c(0,0,0,0))\n    \n    lapply(1:n_plot, function(i){\n              output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlotly({\n                        theGraph <- fun.histPlot(graphData, no.bins=input$numbins,\n                                                 meas=hmeas[i], group_var=input$hgroup,\n                                                 flag.facet = input$chkb.hfacet,  \n                                                 flag.save=input$saveHPlot)\n                        \n                        # Convert the ggplot to a plotly\n                        theGraph <- ggplotly(theGraph)\n                        \n              }) # end renderPlot()\n    }) # end lapply\n  })     \n   \n  ##### Create divs ######\n  output$hist_plots <- renderUI({\n    #  Re-run when button is clicked\n        if (input$View.Hist == 0){\n          return() }\n        else{\n          isolate({\n                  n_plot <- length(input$hmeasure)\n                  plot_output_list <- lapply(1:n_plot, function(i) {\n                            plotname <- paste(\"plot\", i, sep=\"\")\n                            #plotOutput(plotname)\n                            plotlyOutput(plotname, height = 800, width = 800)\n                  })   \n                  do.call(tagList, plot_output_list)\n                  multiHistPlotsOutput()\n          })\n        } \n  })   \n  \n  #=================================================================================================\n  #\n  # Third Tab functions -- Density Plots\n  #\n  output$dens.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- names(data.cat) \n    selectInput('dgroup', 'Filter:', choices=c(\"None\", group.vars), multiple = FALSE)\n  })\n  #\n  output$dens.measures <- renderUI({\n    data <- passData()\n    meas.vars <- c(\"Start.Av.Weight\", \"End.Av.Weight\", \"Econ.FCR.Period\", \"Mortality.Perc\", \"Mortality.Deviation.Perc\",\n                   \"SFR.Period.Perc\", \"SGR.Period.Perc\", \"Avg.Temp\", \"Av.Wt.Deviation.Perc\", \"Diff.Days\",\n                   \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\")\n    selectInput('dmeasure', 'Measure (x-axis):', choices = sort(meas.vars), multiple = TRUE, \n                selected = \"Econ.FCR.Period\")\n  })\n  #\n  # output$dens_plots <- renderPlot({\n  #   #  Re-run when button is clicked\n  #   if (input$View.Dens == 0){\n  #     return() }\n  #   else{\n  #     isolate({\n  #       graphData <- passData()\n  #       theGraph <- fun.densPlot(graphData, meas=input$dmeasure, group_var=input$dgroup,\n  #                                flag.facet = input$chkb.dfacet, flag.save=input$saveDPlot)\n  #       print(theGraph)\n  #     })\n  #   }\n  # })\n  \n  # Multiple Density plots\n  \n  multiDensPlotsOutput <- reactive({\n    dmeas <- input$dmeasure\n    n_plot <- length(dmeas)\n   \n    graphData <- passData()\n    \n    lapply(1:n_plot, function(i){\n      output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlotly({\n        theGraph <- fun.densPlot(graphData, meas=dmeas[i], group_var=input$dgroup,\n                                 flag.facet = input$chkb.dfacet, flag.save=input$saveDPlot)\n        #print(theGraph)\n        # Convert the ggplot to a plotly\n        theGraph <- ggplotly(theGraph)\n      }) # end renderPlot()\n    }) # end lapply\n  })     \n  \n  ##### Create divs######\n  output$dens_plots <- renderUI({\n    #  Re-run when button is clicked\n    if (input$View.Dens == 0){\n      return() }\n    else{\n      isolate({\n        n_plot <- length(input$dmeasure)\n        plot_output_list <- lapply(1:n_plot, function(i) {\n          plotname <- paste(\"plot\", i, sep=\"\")\n          plotlyOutput(plotname, height = 800, width = 800)\n        })   \n        \n        do.call(tagList, plot_output_list)\n        multiDensPlotsOutput()\n        \n      })\n    } \n  })  \n  \n  #=================================================================================================\n  #\n  # Forth Tab functions -- Boxplots\n  #\n  #\n  output$boxplot.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- names(data.cat) \n    selectInput('bxgroup', 'Filter:', choices=c(\"None\", group.vars), multiple = FALSE)\n  })\n  #\n  output$boxplot.measures <- renderUI({\n    data <- passData()\n    meas.vars <- c(\"Start.Av.Weight\", \"End.Av.Weight\", \"Econ.FCR.Period\", \"Mortality.Perc\", \"Mortality.Deviation.Perc\",\n                   \"SFR.Period.Perc\", \"SGR.Period.Perc\", \"Avg.Temp\", \"Av.Wt.Deviation.Perc\", \"Diff.Days\",\n                   \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\")\n    selectInput('bxmeasure', 'Measure (x-axis):', choices = sort(meas.vars), multiple = TRUE, \n                selected = \"Econ.FCR.Period\")\n  })\n  #\n  # output$box_plots <- renderPlot({\n  #   #  Re-run when button is clicked\n  #   if (input$View.Boxplot == 0){\n  #     return() }\n  #   else{\n  #     isolate({\n  #       graphData <- passData()\n  #       theGraph <- fun.boxPlot(graphData, meas=input$bxmeasure, group_var=input$bxgroup, flag.notch = input$chkb.bxnotch,\n  #                                flag.facet = input$chkb.bxfacet, flag.save=input$saveBoxPlot)\n  #       print(theGraph)\n  #     })\n  #   }\n  # })\n  \n  # Multiple Boxplots\n  \n  multiBoxPlotsOutput <- reactive({\n    bxmeas <- input$bxmeasure\n    n_plot <- length(bxmeas)\n    \n    graphData <- passData()\n    \n    lapply(1:n_plot, function(i){\n      output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlotly({\n                theGraph <- fun.boxPlot(graphData, meas=bxmeas[i], group_var=input$bxgroup, \n                                        flag.notch = input$chkb.bxnotch,\n                                        flag.facet = input$chkb.bxfacet, \n                                        flag.save=input$saveBoxPlot)\n                #print(theGraph)\n                # Convert the ggplot to a plotly\n                theGraph <- ggplotly(theGraph)\n      }) # end renderPlot()\n    }) # end lapply\n  })     \n  \n  ##### Create divs######\n  output$box_plots <- renderUI({\n    #  Re-run when button is clicked\n    if (input$View.Boxplot == 0){\n      return() }\n    else{\n      isolate({\n        n_plot <- length(input$bxmeasure)\n        plot_output_list <- lapply(1:n_plot, function(i) {\n          plotname <- paste(\"plot\", i, sep=\"\")\n          plotlyOutput(plotname, height = 800, width = 800)\n        })   \n        \n        do.call(tagList, plot_output_list)\n        multiBoxPlotsOutput()\n        \n      })\n    } \n  })  \n  \n  #=================================================================================================\n  #\n  # Fifth Tab functions -- Bar plots\n  #\n  #\n  output$bar.dim <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    dim.vars <- names(data.cat) \n    selectInput('barDim', 'Dimension (X):', choices=dim.vars, selected = \"Species\", multiple = FALSE)\n  })  \n  output$bar.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- names(data.cat)[ !(names(data.cat) %in% input$barDim) ]  \n    selectInput('bargroup', 'Filter:', choices=c(\"None\", sort(group.vars)), selected = \"None\", multiple = FALSE)\n  })\n  #\n  output$bar.meas <- renderUI({\n    data <- passData()\n    meas.vars <- c(\"Start.Av.Weight\", \"End.Av.Weight\", \"Econ.FCR.Period\", \"Mortality.Perc\", \"Mortality.Deviation.Perc\",\n                   \"SFR.Period.Perc\", \"SGR.Period.Perc\", \"Avg.Temp\", \"Av.Wt.Deviation.Perc\", \"Diff.Days\",\n                   \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\")\n    selectInput('barMeas', 'Measure:', choices=c(\"None\", sort(meas.vars)), selected = \"None\", multiple = TRUE)\n  })\n  \n  # output$bar_plots <- renderPlot({\n  #   #  Re-run when button is clicked\n  #   if (input$View.Barplots == 0){\n  #     return() }\n  #   else{\n  #     isolate({\n  #       graphData <- passData()\n  #       theGraph <- fun.barPlot(graphData, dimX = input$barDim, group_var = input$bargroup, \n  #                               meas = input$barMeas, flag.save = input$saveBarPlot,\n  #                               flag.sd.se = input$radio.sd.se, flag.facet = input$chkb.barfacet)\n  #       print(theGraph)\n  #     })\n  #   }\n  # })\n  \n  # Multiple Barplots\n  \n  multiBarPlotsOutput <- reactive({\n    brmeas <- input$barMeas\n    n_plot <- length(brmeas)\n    \n    graphData <- passData()\n    \n    lapply(1:n_plot, function(i){\n      output[[paste(\"plot\", i, sep=\"\") ]] <- renderPlotly({\n        theGraph <- fun.barPlot(graphData, dimX = input$barDim, group_var = input$bargroup, \n                                meas=brmeas[i], flag.save = input$saveBarPlot,\n                                flag.sd.se = input$radio.sd.se, flag.facet = input$chkb.barfacet)\n        # print(theGraph)\n        # Convert the ggplot to a plotly\n        theGraph <- ggplotly(theGraph)\n      }) # end renderPlot()\n    }) # end lapply\n  })     \n  \n  ##### Create divs######\n  output$bar_plots <- renderUI({\n    #  Re-run when button is clicked\n    if (input$View.Barplots == 0){\n      return() }\n    else{\n      isolate({\n        n_plot <- length(input$barMeas)\n        plot_output_list <- lapply(1:n_plot, function(i) {\n          plotname <- paste(\"plot\", i, sep=\"\")\n          plotlyOutput(plotname, height = 800, width = 800)\n        })   \n        \n        do.call(tagList, plot_output_list)\n        multiBarPlotsOutput()\n        \n      })\n    } \n  })\n  \n  #=================================================================================================\n  #\n  # Sixth Tab functions -- Scatter plots\n  #\n  #\n  output$sc.dimX <- renderUI({\n    data <- passData()\n    n.numeric <- which(sapply(data, is.numeric))\n    data.num <- data[, n.numeric]\n    dim.vars <- sort(names(data.num)) \n    selectInput('scDimX', 'Dimension (X):', choices=dim.vars, selected = \"Start.Av.Weight\", multiple = FALSE)\n  })  \n  \n  output$sc.dimY <- renderUI({\n    data <- passData()\n    n.numeric <- which(sapply(data, is.numeric))\n    data.num <- data[, n.numeric]\n    dim.vars <- sort( names(data.num)[ !(names(data.num) %in% input$scDimX) ] ) \n    selectInput('scDimY', 'Dimension (Y):', choices=dim.vars, selected = \"Econ.FCR.Period\", multiple = FALSE)\n  })  \n  \n  output$sc.size <- renderUI({\n    data <- passData()\n    n.numeric <- which(sapply(data, is.numeric))\n    data.num <- data[, n.numeric]\n    size.vars <- sort( names(data.num)[ !(names(data.num) %in% c(input$scDimX, input$scDimY)) ] )\n    selectInput('scSize', 'Size:', choices=size.vars, selected = \"Mortality.Perc\", multiple = FALSE)\n  })\n\n  output$sc.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- sort(names(data.cat))\n    selectInput('scgroup', 'Filter:', choices=c(\"None\", group.vars), multiple = FALSE)\n  })\n\n  output$scatter_plots <- renderPlotly({\n  #Re-run when button is clicked\n    if (input$View.Scatterplots == 0){\n      return() }\n    else{\n      isolate({\n        graphData <- passData()\n        p <- fun.scatterPlot(graphData, dimX = input$scDimX, dimY=input$scDimY, Size=input$scSize, group_var = input$scgroup,\n                             regr.method = input$method.regress, flag.save = input$saveScatterPlot)\n        # print(p)\n        # Convert the ggplot to a plotly\n        p <- ggplotly(p)\n      })\n    }\n  })\n\n\n  #=================================================================================================\n  #\n  # Seventh Tab functions -- Summary Table\n  #\n  output$sum.group <- renderUI({\n    data <- passData()\n    ncat <- which(sapply(data, is.factor))\n    data.cat <- data[, ncat]\n    group.vars <- sort(names(data.cat))\n    selectInput('sumgroup', 'Filter:', choices=c(\"None\", group.vars), multiple = TRUE)\n  }) \n  #\n  output$sum.meas <- renderUI({\n    data <- passData()\n    meas.vars <- c(\"Start.Av.Weight\", \"End.Av.Weight\", \"Econ.FCR.Period\", \"Mortality.Perc\", \"Mortality.Deviation.Perc\",\n                   \"SFR.Period.Perc\", \"SGR.Period.Perc\", \"Avg.Temp\", \"Av.Wt.Deviation.Perc\", \"Diff.Days\",\n                   \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\")\n    selectInput('sumMeas', 'Measure:', choices=sort(meas.vars), multiple = FALSE)\n  })\n  \n  output$summary_stats <- renderTable({\n    if (input$View.Stats == 0) {\n      return() }\n    else{\n      isolate({\n        data <- passData()\n        data_stats <- sum_stats(data, measurevar=input$sumMeas, groupvars=input$sumgroup,\n                                na.rm=FALSE, conf.interval=.95, .drop=TRUE, flag.save=input$saveStats)\n      })\n      return(data_stats)\n    }\n  })\n\n  #=================================================================================================\n  #\n  # Function for displaying OLAP cubes - Pivot Tables\n  #\n  #--------------------------------------------------------------------------------------------\n  output$pivotTable <- renderRpivotTable({\n     dataPivot = passData()\n     rpivotTable(dataPivot)\n  })\n\n  #=================================================================================================\n  #\n  # Machine Learning Tab functions \n  #\n  #--------------------------------------------------------------------------------------------\n  #     Training Phase\n  #--------------------------------------------------------------------------------------------\n  #\n  preprocess.MachineLearning <- function( data, list.vars, inpts.vars, response )\n  {\n    dset.train <- data[ , names(data) %in% unlist(list.vars) ]\n    dummy.ds <- dummyVars(\"~.\", data=dset.train[inpts.vars], sep=\".\", fullRank=F)\n    dummy.dset.train <- data.frame(predict(dummy.ds, newdata = dset.train), dset.train[response])\n    dummy.preds <- names( dummy.dset.train )[names(dummy.dset.train) != response]\n    \n    # Remove unused columns\n    pos.zeros <- which( colSums(dummy.dset.train)==0 )\n    if ( length(pos.zeros) != 0 ){\n      dummy.dset.train <- dummy.dset.train[,-pos.zeros]\n      dummy.preds <- dummy.preds[-pos.zeros]\n    }\n    \n    # Create a new (dummy) formula\n    dummy.fmla <- as.formula(paste(response,\" ~ \",paste(dummy.preds, collapse=\"+\")))\n    \n    #----------------------------------- Preprocess\n    #\n    # Identifying Correlated Predictors\n    descrCor <- cor(dummy.dset.train[ dummy.preds ])\n    highlyCorDescr <- findCorrelation(descrCor, cutoff = .95)\n    if ( length(highlyCorDescr) != 0 )\n    {\n      dummy.dset.train <- dummy.dset.train[, -highlyCorDescr]\n      dummy.preds <- names( dummy.dset.train )[names(dummy.dset.train) != response]\n      dummy.fmla <- as.formula(paste(response,\" ~ \",paste(dummy.preds, collapse=\"+\")))\n    }\n    #\n    # The preProcess class can be used for many operations on predictors, \n    #   including centering and scaling.\n    #\n    dp <- intersect(dummy.preds, inpts.vars)\n    pre.data <- dummy.dset.train[ , names(dummy.dset.train) %in% dp ]\n    pre.data <- pre.data[ names(pre.data) != response ]\n    \n    if ( ncol(as.data.frame(pre.data)) == 1 ){\n      pre.data <- data.frame(pre.data)\n    }\n    if( nrow(pre.data) !=0 )\n    {\n      preProcValues <- preProcess(pre.data, method = c(\"center\", \"scale\"))\n      preproc.dummy.dset.train <- predict(preProcValues, dummy.dset.train)\n    }else{\n      preproc.dummy.dset.train <- dummy.dset.train\n    }\n    \n    return( list(newdata = preproc.dummy.dset.train, fmla = dummy.fmla) )\n    \n  } # end preprocess.MachineLearning\n  #------------------------------------------------------------------------------------------- \n  #\n  output$targs.ML.Variables <- renderUI({ \n    \n    selectInput(inputId='Targ.ML.Var', label=h3('Target (Response) Variable:'), \n                choices=c(\"Econ.FCR.Period\", \"SGR.Period.Perc\", \"Av.Wt.Deviation.Perc\", \"Mortality.Perc\",\n                          \"LTD.Mortality.Perc\", \"LTD.Econ.FCR\"), \n                selected=\"Econ.FCR.Period\", multiple=FALSE)\n  })  # end renderUI targs.Variables\n  #\n  output$preds.ML.Variables <- renderUI({\n    data <- passData() \n    Vars <- names(data)\n    ind.vars <- Vars[ Vars != input$Targ.ML.Var] \n    selectInput(inputId='Preds.ML.Vars', label=h3('Predictors:'), choices=ind.vars, multiple=TRUE)\n  })  # end renderUI preds.Variables\n  #\n  output$fmla.model <- renderText({\n    if (input$goAnalysis == 0){\n      return() }\n    else{ \n      isolate({   \n        fmla = paste( as.character(input$Targ.ML.Var), \n                      paste(as.character(input$Preds.ML.Vars), collapse=\" + \"), sep=\" ~ \" )\n      })  # end isolate\n    } # end if...else\n  })\n \n  #\n  #-----------------------------------------------\n  #     Create Model --- SVM function\n  #-----------------------------------------------\n  runSVM <- reactive({\n    \n    response <- input$Targ.ML.Var\n    inpts.vars <- input$Preds.ML.Vars \n    list.vars <- list(response, inpts.vars)\n    \n    # \"data\": dataset that based on the user choices in the first page\n    data <- passData()  \n    \n    # Call Machine Learning preprocess function\n    preprocML <- preprocess.MachineLearning( data, list.vars, inpts.vars, response )\n    \n    preproc.dummy.dset.train = preprocML$newdata\n    dummy.fmla <- preprocML$fmla\n    \n    #----------------------------------- Train the model\n    #\n    # Setting training controls --- cross-validation\n    #\n    #---------- Customized the parameters\n    set.seed(123)\n    reps = 10\n    kfolds = input$folds\n    times = reps*kfolds\n    \n    nr <- nrow(preproc.dummy.dset.train)\n    perc <- 0.75\n    \n    seeds <- vector(mode = \"list\", length = times)\n    \n    for(i in 1:times) seeds[[i]] <- sample.int(nr, round(nr*perc,digits=1))\n    \n    ## For the last model:\n    seeds[[times + 1]] <- sample.int(nr, 1)\n    \n    set.seed(1)\n    \n    fitControl <- trainControl(## 10-fold CV\n      method = \"repeatedcv\",\n      number = kfolds,\n      ## repeated ten times\n      repeats = reps,\n      ## set seeds\n      seeds = seeds)\n    \n    svm.model <- train(dummy.fmla, data=preproc.dummy.dset.train, method = \"svmRadial\", na.action=na.omit,\n                    trControl = fitControl, metric=\"RMSE\")\n    \n    #------------------ Save into file the training dataset with response variable\n    #\n    Training.Dset <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),preproc.dummy.dset.train)\n    write.xlsx(Training.Dset, file=\"Training.Dset.SVM.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    Training.Dset.RealValues <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),\n                                  data[ row.names(data) == row.names(preproc.dummy.dset.train), ])\n    write.xlsx(Training.Dset.RealValues, file=\"Training.Dset.SVM.RealValues.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    return(svm.model)\n  })\n  \n  #\n  #-----------------------------------------------------------------------------------\n  #     Create Model --- GLM function\n  #-----------------------------------------------------------------------------------\n  runGLM.Boosting <- reactive({\n    \n    response <- input$Targ.ML.Var\n    inpts.vars <- input$Preds.ML.Vars \n    list.vars <- list(response, inpts.vars)\n    \n    # \"data\": dataset that based on the user choices in the first page\n    data <- passData()  \n    \n    # Call Machine Learning preprocess function\n    preprocML <- preprocess.MachineLearning( data, list.vars, inpts.vars, response )\n    \n    preproc.dummy.dset.train <- preprocML$newdata\n    dummy.fmla <- preprocML$fmla\n    \n    #----------------------------------- Train the model\n    #\n    # Setting training controls --- cross-validation\n    #\n    \n    #---------- Customized the parameters\n    set.seed(123)\n    reps = 10\n    kfolds = input$folds\n    times = reps*kfolds\n    \n    nr <- nrow(preproc.dummy.dset.train)\n    perc <- 0.75\n    \n    seeds <- vector(mode = \"list\", length = times)\n    \n    for(i in 1:times) seeds[[i]] <- sample.int(nr, round(nr*perc,digits=1))\n    \n    # For the last model:\n    seeds[[times + 1]] <- sample.int(nr, 1)\n    \n    set.seed(1)\n    \n    fitControl <- trainControl(## 10-fold CV\n      method = \"repeatedcv\",\n      number = kfolds,\n      # repeated ten times\n      repeats = reps,\n      # set seeds\n      seeds = seeds)\n    \n    glmnet.model <- train(dummy.fmla, data=preproc.dummy.dset.train, method = \"glmboost\", trControl = fitControl,\n                          na.action=na.omit, metric=\"RMSE\")\n    \n    #------------------ Save into file the training dataset with response variable\n    #\n    Training.Dset <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train), preproc.dummy.dset.train)\n    write.xlsx(Training.Dset, file=\"Training.Dset.GLMBoosting.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    Training.Dset.RealValues <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),\n                                           data[ row.names(data) == row.names(preproc.dummy.dset.train), ])\n    write.xlsx(Training.Dset.RealValues, file=\"Training.Dset.GLMBoosting.RealValues.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    return(glmnet.model)\n    \n  })\n  \n  \n  #-------------------------------------------------------------------------------------------\n  #     Create Model --- GAM function \n  #-------------------------------------------------------------------------------------------\n  runGAM <- reactive({ })\n  \n  #-------------------------------------------------------------------------------------------\n  #     Create Model --- Random Forest function \n  #-------------------------------------------------------------------------------------------\n  runRF <- reactive({ \n    \n    response <- input$Targ.ML.Var\n    inpts.vars <- input$Preds.ML.Vars \n    list.vars <- list(response, inpts.vars)\n    \n    # \"data\": dataset that based on the user choices in the first page\n    data <- passData()  \n    \n    # Call Machine Learning preprocess function\n    preprocML <- preprocess.MachineLearning( data, list.vars, inpts.vars, response )\n    \n    preproc.dummy.dset.train = preprocML$newdata\n    dummy.fmla <- preprocML$fmla\n    \n    #----------------------------------- Train the model\n    #\n    # Setting training controls --- cross-validation\n    #\n    \n    #---------- Customized the parameters\n    set.seed(123)\n    reps = 10\n    kfolds = input$folds\n    times = reps*kfolds\n    \n    nr <- nrow(preproc.dummy.dset.train)\n    perc <- 0.75\n    \n    seeds <- vector(mode = \"list\", length = times)\n    \n    for(i in 1:times) seeds[[i]] <- sample.int(nr, round(nr*perc,digits=1))\n    \n    ## For the last model:\n    seeds[[times + 1]] <- sample.int(nr, 1)\n    \n    set.seed(1)\n    \n    fitControl <- trainControl(## 10-fold CV\n      method = \"repeatedcv\",\n      number = kfolds,\n      ## repeated ten times\n      repeats = reps,\n      ## set seeds\n      seeds = seeds)\n    \n    rf.model <- train(dummy.fmla, data=preproc.dummy.dset.train, method = \"rf\", trControl = fitControl,\n                      na.action=na.omit, metric=\"RMSE\")\n    \n    #------------------ Save into file the training dataset with response variable\n    #\n    Training.Dset <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),preproc.dummy.dset.train)\n    write.xlsx(Training.Dset, file=\"Training.Dset.RF.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    Training.Dset.RealValues <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),\n                                           data[ row.names(data) == row.names(preproc.dummy.dset.train), ])\n    write.xlsx(Training.Dset.RealValues, file=\"Training.Dset.RF.RealValues.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    return(rf.model)\n    \n  })\n  \n  #-------------------------------------------------------------------------------------------\n  #     Create Model --- Multivariate Adaptive Regression Spline (MARS) function\n  #-------------------------------------------------------------------------------------------\n  runMARS <- reactive({ \n    \n    response <- input$Targ.ML.Var\n    inpts.vars <- input$Preds.ML.Vars \n    list.vars <- list(response, inpts.vars)\n    \n    # \"data\": dataset that based on the user choices in the first page\n    data <- passData()  \n    \n    # Call Machine Learning preprocess function\n    preprocML <- preprocess.MachineLearning( data, list.vars, inpts.vars, response )\n    \n    preproc.dummy.dset.train = preprocML$newdata\n    dummy.fmla <- preprocML$fmla\n    \n    #----------------------------------- Train the model\n    #\n    # Setting training controls --- cross-validation\n    #\n    \n    #---------- Customized the parameters\n    set.seed(123)\n    reps = 10\n    kfolds = input$folds\n    times = reps*kfolds\n    \n    nr <- nrow(preproc.dummy.dset.train)\n    perc <- 0.75\n    \n    seeds <- vector(mode = \"list\", length = times)\n    \n    for(i in 1:times) seeds[[i]] <- sample.int(nr, round(nr*perc,digits=1))\n    \n    ## For the last model:\n    seeds[[times + 1]] <- sample.int(nr, 1)\n    \n    set.seed(1)\n    \n    fitControl <- trainControl(## 10-fold CV\n      method = \"repeatedcv\",\n      number = kfolds,\n      ## repeated ten times\n      repeats = reps,\n      ## set seeds\n      seeds = seeds)\n    \n    marsGrid <- expand.grid(degree = 1:2, nprune = (1:4) * 10)\n    \n    mars.model <- train(dummy.fmla, data=preproc.dummy.dset.train, method = \"earth\", tuneGrid = marsGrid,\n                      trControl = fitControl, metric=\"RMSE\", na.action=na.omit)\n    \n    #------------------ Save into file the training dataset with response variable\n    #\n    Training.Dset <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),preproc.dummy.dset.train)\n    write.xlsx(Training.Dset, file=\"Training.Dset.MARS.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    Training.Dset.RealValues <- data.frame(\"Cage.ID\"=row.names(preproc.dummy.dset.train),\n                                           data[ row.names(data) == row.names(preproc.dummy.dset.train), ])\n    write.xlsx(Training.Dset.RealValues, file=\"Training.Dset.MARS.RealValues.xlsx\", col.names=TRUE, row.names=FALSE)\n    \n    return(mars.model)\n    \n  })\n  \n  #----------------------------------------------------\n  #\n  output$summary_model <- renderPrint({\n    if (input$goAnalysis == 0){\n      return() }\n    else{ \n      isolate({   \n        if ( !is.null(input$Targ.ML.Var) ){\n          \n          # if SVM \n          if (input$radioML.model == 1){\n            svm.mod <- runSVM()\n            res <- svm.mod$results[rownames(svm.mod$bestTune), ]\n            print( round(res, digits = 3) ) \n            \n          }else if (input$radioML.model == 2){\n            # if GLM\n            gml.mod <- runGLM.Boosting()\n            res <- gml.mod$results[rownames(gml.mod$bestTune),]\n            print( round(res, digits = 3) ) \n        \n          } else if (input$radioML.model == 4){ \n            # if Random Forest\n            rf.mod <- runRF()\n            res <- rf.mod$results[rownames(rf.mod$bestTune),]\n            print( round(res, digits = 3) ) \n            \n          } else if (input$radioML.model == 5){ \n            # if MARS\n            mars.mod <- runMARS()\n            res <- mars.mod$results[rownames(mars.mod$bestTune),]\n            print( round(res, digits = 3) ) \n          }# end if..else for radioML.model\n          \n          res.df <- data.frame(\"RMSE\"=round(res$RMSE, digits=3),\n                               \"R-Squared\"=round(res$Rsquared, digits=3) )\n          print(res.df)  \n        \n        }else{ \n          print(data.frame(Warning=\"Please select Model Parameters.\"))\n        } # end if...else\n      }) # end isolate\n    } # end if...else\n  })  \n  \n  #----------------------------------------------------\n  #\n  output$approvalBox.RMSE <- renderInfoBox({\n    \n    if (input$goAnalysis == 0){\n      return() }\n    else{ \n      isolate({   \n        if ( !is.null(input$Targ.ML.Var) ){\n          \n          # if SVM \n          if (input$radioML.model == 1){\n            svm.mod <- runSVM()\n            res <- svm.mod$results[rownames(svm.mod$bestTune), ]\n            \n          }else if (input$radioML.model == 2){\n            # if Boosting GLM\n            gml.mod <- runGLM.Boosting()\n            res <- gml.mod$results[rownames(gml.mod$bestTune),]\n            \n        # } else if (input$radioML.model == 3){...}  \n            \n          } else if (input$radioML.model == 4){ \n            # if Random Forest model\n            \n            rf.mod <- runRF()\n            res <- rf.mod$results[rownames(rf.mod$bestTune), ]\n            \n          } else if (input$radioML.model == 5){ \n            # if MARS model\n            \n            mars.mod <- runMARS()\n            res <- mars.mod$results[rownames(mars.mod$bestTune), ]  \n            \n          }# end if..else for radioML.model\n          \n          res.df <- data.frame(\"RMSE\"=round(res$RMSE,digits=3),\n                               \"R-Squared\"=round(res$Rsquared,digits=3) )\n          \n          if (res.df$RMSE <= 0.3){\n            infoBox(\n              \"Success\", res.df$RMSE, icon = icon(\"thumbs-up\", lib = \"glyphicon\"),\n              color = \"green\", fill = TRUE\n            )\n          }else if (res.df$RMSE > 0.3 & res.df$RMSE <= 0.6 ){\n            infoBox(\n              \"Warning\", res.df$RMSE, icon = icon(\"thumbs-warning-sign\", lib = \"glyphicon\"),\n              color = \"yellow\", fill = TRUE\n            )\n          }else{\n            infoBox(\n              \"Danger\", res.df$RMSE, icon = icon(\"thumbs-down\", lib = \"glyphicon\"),\n              color = \"red\", fill = TRUE\n            )\n          } # end if..else infoBoxes\n        \n        }else{ \n          print(data.frame(Warning=\"Please select Model Parameters.\"))\n        } # end if...else\n        \n        }) # end isolate\n      } # end if...else\n    \n  })\n  #------------------------------- \n  output$approvalBox.Rsquare <- renderInfoBox({\n    \n    if (input$goAnalysis == 0){\n      return() }\n    else{ \n      isolate({   \n        if ( !is.null(input$Targ.ML.Var) ){\n          \n          # if SVM \n          if (input$radioML.model == 1){\n            svm.mod <- runSVM()\n            res <- svm.mod$results[rownames(svm.mod$bestTune), ]\n            \n          }else if (input$radioML.model == 2){\n            # if GLM\n            gml.mod <- runGLM.Boosting()\n            res <- gml.mod$results[rownames(gml.mod$bestTune),]\n            \n            # } else if (input$radioML.model == 3){...} \n            \n          }else if (input$radioML.model == 4){ \n            # if Random Forest model\n            rf.mod <- runRF()\n            res <- rf.mod$results[rownames(rf.mod$bestTune), ]\n          \n          }else if (input$radioML.model == 5){ \n            # if MARS model\n            mars.mod <- runMARS()\n            res <- mars.mod$results[rownames(mars.mod$bestTune), ]\n          \n          }# end if..else for radioML.model\n          \n          res.df <- data.frame(\"RMSE\"=round(res$RMSE,digits=3),\n                               \"R.Squared\"=round(res$Rsquared,digits=3) )\n          \n          if (res.df$R.Squared >= 0.7){\n            infoBox(\n              \"Success\", res.df$R.Squared, icon = icon(\"thumbs-up\", lib = \"glyphicon\"),\n              color = \"green\", fill = TRUE\n            )\n          }else if (res.df$R.Squared >= 0.5 & res.df$R.Squared < 0.7 ){\n            infoBox(\n              \"Warning\", res.df$R.Squared, icon = icon(\"thumbs-warning-sign\", lib = \"glyphicon\"),\n              color = \"yellow\", fill = TRUE\n            )\n          }else if (res.df$R.Squared < 0.5){\n            infoBox(\n              \"Danger\", res.df$R.Squared, icon = icon(\"thumbs-down\", lib = \"glyphicon\"),\n              color = \"red\", fill = TRUE\n            )\n          } # end if..else infoBoxes\n          \n        }else{ \n          print(data.frame(Warning=\"Please select Model Parameters.\"))\n        } # end if...else\n        \n      }) # end isolate\n    } # end if...else\n    \n  })\n  \n  \n  #---------------------------------------------\n  output$ML.Var.Impo <- renderPrint({ \n      if (input$goAnalysis == 0){\n         return() }\n      else{\n        isolate({\n              # if SVM \n              if (input$radioML.model == 1){\n                    svm.mod <- runSVM()\n                    varImp.svm <- varImp(svm.mod, scale = FALSE)\n                    vimp.df <- data.frame(\"Features\" = rownames(varImp.svm$importance),\n                                          \"Importance\" = round( varImp.svm$importance$Overall, digits = 3 ))\n                    \n                    # Remove NA or equal to zeros\n                    vimp.df.gr0.na <- vimp.df %>% filter( Importance > 0 & !is.na(Importance) ) \n                    \n                    # Calculate Variance Importance as percentage\n                    vimp.df.gr0.na$Importance <- round(vimp.df.gr0.na$Importance * 100/sum(vimp.df.gr0.na$Importance),\n                                                       digits = 3)\n                    \n                    # Sorting variables by descenting order in terms of Importance\n                    sort.vimp.df.gr0.na <- vimp.df.gr0.na[ order(-vimp.df.gr0.na$Importance),]\n                    \n                    print(sort.vimp.df.gr0.na, justify=\"left\", row.names=FALSE)\n                    \n              }else if (input$radioML.model == 2){\n                    # if Boosting GLMnet\n                    gml.mod <- runGLM.Boosting()\n                    RocImp <- varImp(gml.mod, scale = FALSE)\n                    \n                    results <- data.frame(row.names(RocImp$importance),RocImp$importance$Overall)\n                    results$VariableName <- rownames(RocImp)\n                    colnames(results) <- c('Features','Importance')\n                    \n                    results$Importance <- round(results$Importance * 100/sum(results$Importance), digits = 3) \n                    \n                    # Sorting variables by descenting order in terms of Importance\n                    sort.RocImp <- results[ order(-results$Importance),]\n                    print(sort.RocImp, digits=3, justify=\"left\", row.names=FALSE)\n                    \n                    # }else if (input$radioML.model == 3){ ... }   \n                    \n              }else if (input$radioML.model == 4){ \n                # if Random Forest\n                \n                    rf.mod <- runRF()\n                    RocImp <- data.frame('Features'=rownames(rf.mod$finalModel$importance), \n                                         'Importance'=rf.mod$finalModel$importance)\n                    colnames(RocImp) <- c('Features','Importance')  \n                    \n                    RocImp$Importance <- round(RocImp$Importance * 100/sum(RocImp$Importance), digits = 3) \n                    \n                    # Sorting variables by descenting order in terms of Importance\n                    sort.RocImp <- RocImp[ order(-RocImp$Importance),]\n                    print(sort.RocImp, digits=3, justify=\"left\", row.names=FALSE) \n                   \n              }else if (input$radioML.model == 5){ \n                # if MARS\n                \n                    mars.mod <- runMARS()\n                    \n                    varImp.mars <- varImp(mars.mod, scale = FALSE)\n                    RocImp <- data.frame(\"Features\" = rownames(varImp.mars$importance),\n                                         \"Importance\" = round( varImp.mars$importance$Overall, digits = 3 ))\n                    \n                    colnames(RocImp) <- c('Features','Importance')  \n                    \n                    RocImp$Importance <- round(RocImp$Importance * 100/sum(RocImp$Importance), digits = 3) \n                    \n                    # Sorting variables by descenting order in terms of Importance\n                    sort.RocImp <- RocImp[ order(-RocImp$Importance),]\n                    print(sort.RocImp, digits=3, justify=\"left\", row.names=FALSE) \n                 \n              } # end if..else for radioML.model    \n        })\n      }\n  })\n  #\n  output$plot_ML_Var_Impo <- renderPlotly({\n      if (input$goAnalysis == 0){\n            return() }\n      else{\n          isolate({\n            # if SVM \n            if (input$radioML.model == 1){\n            \n                  svm.mod <- runSVM()\n                  varImp.svm <- varImp(svm.mod, scale = FALSE)\n                  vimp.df <- data.frame(\"Features\" = rownames(varImp.svm$importance),\n                                        \"Importance\" = round( varImp.svm$importance$Overall, digits = 3 ))\n                  \n                  # Remove NA or equal to zeros\n                  vimp.df.gr0.na <- vimp.df %>% filter( Importance > 0 & !is.na(Importance) ) \n                  \n                  # Calculate Variance Importance as percentage\n                  vimp.df.gr0.na$Importance <- round(vimp.df.gr0.na$Importance * 100/sum(vimp.df.gr0.na$Importance), \n                                                     digits = 3)                \n                  \n                  # Sorting variables by descenting order in terms of Importance\n                  sort.vimp.df.gr0.na <- vimp.df.gr0.na[ order(-vimp.df.gr0.na$Importance),]\n                \n                  # Plot the Variable Importance\n                  p <- ggplot(sort.vimp.df.gr0.na, aes(x = reorder(Features, Importance), y = Importance,\n                                                       text=paste(\"Feature:\", Features) )) +\n                    geom_bar(stat = \"identity\", fill=\"steelblue\") + xlab(\"Features\") + ylab(\"Importance (%)\") +\n                    theme_economist(dkpanel=TRUE) + ggtitle(\"Variance Importance (%) using SVM model\")\n                  p <- p + coord_flip()\n                  \n                  ggplotly(p)\n                  \n                  # Save the figure\n                  # fig.name <- \"Fig.Variance.Importance.png\"\n                  # ggsave(fig.name, p, type=\"cairo-png\", width = 17.58, height = 20.29, units=\"cm\")\n                  \n            }else if (input$radioML.model == 2){  # if Boosting GLM\n                  \n                  gml.mod <- runGLM.Boosting()\n                  RocImp <- varImp(gml.mod, scale = FALSE)\n                  \n                  results <- data.frame(row.names(RocImp$importance),RocImp$importance$Overall)\n                  results$VariableName <- rownames(RocImp)\n                  colnames(results) <- c('VariableName','Class')\n                  results <- results[order(results$Class),]\n                  results <- results[(results$Class != 0),]\n                  results$Importance <- round(results$Class * 100/sum(results$Class), digits = 3) \n                  results$barcol <- ifelse((results$Class > 0), 'blue', 'red')\n            \n                  xx <- ggplot(results, aes(x = reorder(VariableName, Importance), y = Importance,\n                                            text=paste(\"Feature:\", VariableName) )) +\n                    geom_bar(stat = \"identity\", fill=\"steelblue\", width = 0.25) + \n                    ylab(\"< (-) importance >  < neutral >  < importance (+) >\") + \n                    xlab(\"Features\") + ggtitle(\"Variance Importance (%) using GLM model\") + \n                    theme_economist(dkpanel=TRUE) + scale_color_manual(aes(color=barcol))\n                  xx <- xx + coord_flip()\n                  \n                  ggplotly(xx)\n                  \n            # }else if (input$radioML.model == 3){ ... } \n            }else if (input$radioML.model == 4){ \n              # if Random forest \n              rf.mod <- runRF()\n              RocImp <- data.frame('Features'=rownames(rf.mod$finalModel$importance), \n                                   'Importance'=rf.mod$finalModel$importance)\n              colnames(RocImp) <- c('Features','Importance')  \n              \n              # Remove NA or equal to zeros\n              vimp.df.gr0.na <- RocImp %>% filter( Importance > 0 & !is.na(Importance) ) \n              \n              # Calculate Variance Importance as percentage\n              vimp.df.gr0.na$Importance <- round(vimp.df.gr0.na$Importance * 100/sum(vimp.df.gr0.na$Importance), \n                                                 digits = 3)                      \n              \n              # Plot the Variable Importance\n              p <- ggplot(vimp.df.gr0.na, aes(x = reorder(Features, Importance), y = Importance)) +\n                geom_bar(stat = \"identity\", fill=\"steelblue\") +\n                geom_text(aes(label=Importance), hjust=-0.1, color=\"black\", size=3.5) + \n                xlab(\"Features\") + ylab(\"Importance (%)\") +  \n                theme_economist(dkpanel=TRUE) + scale_color_manual(aes(color=barcol))\n              p <- p + coord_flip()\n              \n              ggplotly(p)     \n          \n            }else if (input$radioML.model == 5){ \n              # if MARS\n              mars.mod <- runMARS()\n              \n              varImp.mars <- varImp(mars.mod, scale = FALSE)\n              RocImp <- data.frame(\"Features\" = rownames(varImp.mars$importance),\n                                   \"Importance\" = round( varImp.mars$importance$Overall, digits = 3 ))\n              \n              colnames(RocImp) <- c('Features','Importance')  \n              \n              # Remove NA or equal to zeros\n              vimp.df.gr0.na <- RocImp %>% filter( Importance > 0 & !is.na(Importance) ) \n              \n              # Calculate Variance Importance as percentage\n              vimp.df.gr0.na$Importance <- round(vimp.df.gr0.na$Importance * 100/sum(vimp.df.gr0.na$Importance), \n                                                 digits = 3)                      \n              \n              # Plot the Variable Importance\n              p <- ggplot(vimp.df.gr0.na, aes(x = reorder(Features, Importance), y = Importance)) +\n                geom_bar(stat = \"identity\", fill=\"steelblue\") +\n                geom_text(aes(label=Importance), hjust=-0.1, color=\"black\", size=3.5) + \n                xlab(\"Features\") + ylab(\"Importance (%)\") +  \n                theme_economist(dkpanel=TRUE) + scale_color_manual(aes(color=barcol))\n              p <- p + coord_flip()\n              \n              ggplotly(p)               \n            \n           }  # end if..else\n        }) # end isolate\n      }\n  })\n  \n  #--------------------------------------------------------------------------------------------\n  #     Testing Phase  // Evaluate the Training\n  #--------------------------------------------------------------------------------------------\n  output$plot_Testing <- renderPlotly({\n  \n    if (input$ViewTesting == 0){\n      return() }\n    else{\n      isolate({\n        \n        # Load Training dataset from Excel\n        rootpath <- getwd()\n        response <- input$Targ.ML.Var\n        \n        if (input$radioML.model == 1){  # if SVM \n          flname <- file.path(rootpath,\"Training.Dset.SVM.xlsx\")\n          ds.training <- read_excel(flname, sheet = 1, col_names = TRUE)\n          testing.flname <- \"Testing.Dset.SVM.xlsx\"\n          trained.mod <- runSVM()\n        }else if (input$radioML.model == 2){ # if GLM Boosting\n          flname <- file.path(rootpath,\"Training.Dset.GLMBoosting.xlsx\")\n          ds.training <- read_excel(flname, sheet = 1, col_names = TRUE)\n          testing.flname <- \"Testing.Dset.GLMBoosting.xlsx\"\n          trained.mod <- runGLM.Boosting()\n        }else if (input$radioML.model == 4){ # if Random Forest\n          flname <- file.path(rootpath,\"Training.Dset.RF.xlsx\")\n          ds.training <- read_excel(flname, sheet = 1, col_names = TRUE)\n          testing.flname <- \"Testing.Dset.RF.xlsx\"\n          trained.mod <- runRF()\n        }else if (input$radioML.model == 5){ # if MARS\n          flname <- file.path(rootpath,\"Training.Dset.MARS.xlsx\")\n          ds.training <- read_excel(flname, sheet = 1, col_names = TRUE)\n          testing.flname <- \"Testing.Dset.MARS.xlsx\"\n          trained.mod <- runMARS()\n        }        \n        \n        # Remove cases with NAs\n        ds.training.no.NAs <- ds.training[complete.cases(ds.training), ]\n    \n        # Choose randomly a perc of population for testing\n        nr <- nrow(ds.training.no.NAs)\n        p <- input$perc\n        ids <- sample(1:nr, round(nr*p/100,0), replace = FALSE) \n        ds.testing <- ds.training.no.NAs[ ids, ]\n   \n        #------------------ Testing Phase\n        test.patterns <- ds.testing[ , !(names(ds.testing) %in% response) ]\n        test.targets <- ds.testing[ , response]\n\n        testPred <- predict( trained.mod, test.patterns )\n        rel.error <- (testPred - ds.testing[ , response])*100/ds.testing[ , response] \n        names(rel.error) <- \"Rel.Err\"\n        \n        #----- Estimate Relative Error of prediction for each observation\n        ds.testing$Model.Preds <- testPred\n        ds.testing <- cbind(ds.testing, rel.error)  \n        \n        #------------------ Save into file the testing dataset with response variable and Relative Error\n        #\n        write.xlsx(ds.testing, file=testing.flname, col.names=TRUE, row.names=FALSE)\n        \n        #-------- Plot Relative Error\n        ds <- data.frame( ds.testing$Cage.ID, ds.testing$Model.Preds, \n                          ds.testing[ , response], ds.testing$Rel.Err )\n        names(ds) <- c(\"Cage.ID\", \"Model.Prediction\", \"Actual.Response\", \"Rel.Err\")\n    \n        # Filter mdata according to the Relative Error Threshold\n        ds <- ds %>% filter( abs(Rel.Err) >= input$thresh.RE[1] &\n                             abs(Rel.Err) <= input$thresh.RE[2] ) \n        \n       mdata <- melt(ds, id=c(\"Cage.ID\",\"Rel.Err\"))\n       names(mdata) <- c(\"Cage.ID\", \"Rel.Err\", \"Category\", \"Response\")\n       max.val <- max(mdata$Response)\n        \n        #png(\"BarPlot_Actual.Preds.png\", width = 640, height = 480)\n        p1 <- ggplot(mdata, aes(x=Cage.ID, y=Response, fill=Category,\n                                text=paste(\"Rel.Error:\", round(Rel.Err,digits = 3) ))) +\n                  geom_bar(stat = \"identity\", position=position_dodge()) +\n                 # geom_text(aes(y=Response, ymax=Response, label=round(Response, 1)), \n                  #          position= position_dodge(width=1), vjust=0, color=\"black\", size=3) +\n                  scale_y_continuous(\"Response\", limits=c(0,max.val), breaks=seq(0, max.val, .5)) + \n                  scale_x_discrete(\"Cage.ID\") + scale_fill_brewer(palette=\"Set1\") +\n                  theme_economist(stata = TRUE) + scale_color_economist() + \n                  theme(legend.position=\"bottom\", legend.title = element_blank()) +\n                  ggtitle(\"Actual Response Values V.S. Estimated Model values\") +\n                  coord_flip()\n        \n          if( input$saveTesting ){\n            fig.name <- paste(\"Fig.Testing\", response, \"Rel.Err.Thresh\", input$thresh.RE[1],\"To\",\n                              input$thresh.RE[2], \"png\", sep=\".\")\n            ggsave(fig.name, p1, type=\"cairo-png\", width = 17.58, height = 20.29, units=\"cm\")\n          }\n        \n        ggplotly(p1)\n        \n      }) # end isolate\n    } # end if..else\n    \n  })\n  #--------------------------------------------------\n  output$evaluate_model <- renderPrint({\n    if (input$ViewTesting == 0){\n      return() }\n    else{ \n      isolate({   \n  \n        # Load Testing dataset from Excel & ML Models\n        rootpath <- getwd()\n        response <- input$Targ.ML.Var\n        \n        if (input$radioML.model == 1){  # if SVM \n          flname <- file.path(rootpath, \"Testing.Dset.SVM.xlsx\")\n          ds.testing <- read_excel(flname, sheet = 1, col_names = TRUE)\n          trained.mod <- runSVM()\n        }else if (input$radioML.model == 2){ # if GLM Boosting\n          flname <- file.path(rootpath, \"Testing.Dset.GLMBoosting.xlsx\")\n          ds.testing <- read_excel(flname, sheet = 1, col_names = TRUE)\n          trained.mod <- runGLM.Boosting()\n        }else if (input$radioML.model == 4){ # if Random Forest \n          flname <- file.path(rootpath, \"Testing.Dset.RF.xlsx\")\n          ds.testing <- read_excel(flname, sheet = 1, col_names = TRUE)\n          trained.mod <- runRF()\n        }else if (input$radioML.model == 5){ # if MARS \n          flname <- file.path(rootpath, \"Testing.Dset.MARS.xlsx\")\n          ds.testing <- read_excel(flname, sheet = 1, col_names = TRUE)\n          trained.mod <- runMARS()\n        }  \n        \n        #-------- Plot Relative Error\n        ds <- data.frame( \"Cage.ID\"= ds.testing$Cage.ID,\n                          \"Model.Prediction\"=ds.testing$Model.Preds, \n                          \"Actual.Response\" = ds.testing[ , names(ds.testing) %in% response], \n                          \"Rel.Err\"= ds.testing$Rel.Err )\n        names(ds) <- c(\"Cage.ID\",\"Model.Prediction\",\"Actual.Response\",\"Rel.Err\")\n      \n        # Filter mdata according to the Relative Error Threshold\n        ds <- ds %>% filter( abs(Rel.Err) >= input$thresh.RE[1] &\n                               abs(Rel.Err) <= input$thresh.RE[2] ) \n  \n        # Calculate the coefficient of determination (R-squared)\n        #\n        real.mean <- round( mean(ds$Actual.Response), digits=3 )\n        #---> The regression sum of squares, also called the explained sum of squares\n        ESS <- round( sum( (ds$Model.Prediction - real.mean)^2 ), digits=3 )\n        #---> The sum of squares of residuals, also called the residual sum of squares\n        RSS <- round( sum( (ds$Actual.Response - ds$Model.Prediction)^2 ), digits = 3 )\n        #---> The total sum of squares (proportional to the variance of the data)\n        SS.tot <- round( sum( (ds$Actual.Response - real.mean)^2 ), digits = 3)\n        \n        R.squared <- round(1 - RSS/SS.tot, digits = 3 )\n        \n        # Fraction of unexplained variance (FUV)\n        FUV = round( 1 - R.squared, digits = 3)\n       \n        # Root Mean Squared Error\n        nr <- nrow(ds)\n        RMSE <- round( sqrt( sum( (ds$Model.Prediction - ds$Actual.Response)^2 )/nr ),\n                       digits = 3 )\n        \n        results <- list( \"R.Squared\"=R.squared, \"Root Mean Squared Error\"=RMSE,\n                         \"Fraction of Unexplained Variance\"=FUV,\n                         \"Explained Sum of Squares\"=ESS, \"Residual Sum of Squares\"=RSS,\n                         \"Total Sum of Squares\"=SS.tot) \n    \n        print( results )\n      \n      })\n    }\n  })\n        \n  #--------------------------------------------------------------------------------------------\n  #     Prediction Phase\n  #--------------------------------------------------------------------------------------------\n  # Tab: Predict with Machine Learning Models\n  #\n  predict.with.ML.Model <- reactive({\n    \n    # load the ML model\n    if (input$radioML.model == 1){ # if SVM \n      ML.model <- runSVM()\n    }else if (input$radioML.model == 2){ # if GLM Boosting\n      ML.model <- runGLM.Boosting()\n    }else if (input$radioML.model == 4){ # if Random Forest     \n      ML.model <- runRF()\n    }else if (input$radioML.model == 5){ # if MARS     \n      ML.model <- runMARS()\n    }  \n    \n    # load the dataset\n    data <- passData()\n    \n    # create an instance from the input values (user-defined values)\n    list.predictors <- input$Preds.ML.Vars\n    num.preds <- length(list.predictors)\n    response <- input$Targ.ML.Var\n    fmla <- as.formula( paste(\" \", paste(input$Preds.ML.Vars, collapse=\"+\"), sep=\" ~ \") )\n    \n    newdata <- as.data.frame(matrix(0, nrow = 1, ncol=num.preds))\n    newdata <- lapply(1:num.preds, function(i) {\n      input_name <- paste0(\"input\", i, sep=\"\")\n      input[[ input_name ]]\n    } # end function\n    )# end lapply\n    names(newdata) <- list.predictors\n \n    # Dummy dataset & variables\n    tm.data <- rbind(data[ list.predictors ], newdata)\n    names(tm.data) <- list.predictors\n    \n    dummy.instance.data <- dummyVars(\"~.\", data=tm.data, fullRank=F)\n    dummy.newdata <- data.frame( predict( dummy.instance.data, newdata = tm.data), 'Class'=NA)\n    names(dummy.newdata)[names(dummy.newdata)==\"Class\"] <- response\n  \n    # The preProcess class can be used for many operations on predictors,\n    #  including centering and scaling.\n    dummy.preds <- names( dummy.newdata )[names(dummy.newdata) != response]\n    dp <- intersect(dummy.preds, list.predictors)\n    pre.data <- dummy.newdata[ names(dummy.newdata) %in% dp ]\n    pre.data <- pre.data[ names(pre.data) != response ]\n    \n    if ( ncol(as.data.frame(pre.data)) == 1 ){\n      pre.data <- data.frame(pre.data)\n    }\n    if( nrow(pre.data) !=0 )\n    {\n      preProcValues <- preProcess(pre.data, method = c(\"center\", \"scale\"))\n      preproc.dummy.newdata <- predict(preProcValues, dummy.newdata)\n    }else{\n      preproc.dummy.newdata <- dummy.newdata\n    }\n   \n    dummy.inpts <- as.matrix(data.frame(preproc.dummy.newdata[ nrow(preproc.dummy.newdata), ]))\n    \n    pred_ML_model <- predict(ML.model, dummy.inpts, type=\"raw\", na.action = na.omit)\n    \n    names(pred_ML_model) <- as.character(input$Targ.ML.Var)\n    \n    return(pred_ML_model)\n    \n  })\n  #\n  output$dyn_input.ML <- renderUI({\n    \n    data <- passData()\n    list.predictors <- input$Preds.ML.Vars\n    num.preds <- length(list.predictors)\n    \n    inputs <- lapply(1:num.preds, function(i) {\n      input_name <- paste0(\"input\", i, sep=\"\")\n      fluidRow(column(width=6, \n                      if ( is.factor( data[, list.predictors[[i]]] ) )\n                      {\n                        list.values <- unique( data[, list.predictors[[i]]] )\n                        selectInput(inputId=input_name, label=h4( as.character(list.predictors[[i]]) ), \n                                    choices=as.character(list.values), multiple=FALSE)\n                      }else{  \n                        numericInput( input_name, label = h4( as.character(list.predictors[[i]]) ),\n                                      value = NA)\n                      } # end if...else\n      ) # end column\n      ) # end fluidRow\n    } # end function\n    ) # end lapply\n    \n    do.call(tagList, inputs)\n  }) \n  #\n  # predict value regarding the predictors' values\n  output$prediction.value.ML <- renderPrint({ \n    \n    if (input$goPrediction == 0){\n      return() }\n    else{ \n      isolate({\n        \n        pred_val <- predict.with.ML.Model()\n        names(pred_val) <- as.character(input$Targ.ML.Var)\n        \n        ml.response <- data.frame(pred_val, stringsAsFactors = FALSE)\n        print( ml.response )\n        \n      }) # end isolate\n    } # end if...else\n    \n  })\n  \n  #--------------------------------------------------------------------------------------------\n  #     Page \"KPIs Table estimation\" \n  #--------------------------------------------------------------------------------------------\n  \n  estimateKPI.Table <- reactive({ \n    \n    rate = 0.8\n    predictors <- c(\"Avg.Temp\", \"Period.Av.Weight\")\n    \n    if (input$radioKPI == 1){  \n      response.var <- \"Biol.FCR.Period\"\n    }else if (input$radioKPI == 2){  \n      response.var <- \"Econ.FCR.Period\"\n    }else if (input$radioKPI == 3){ \n      response.var <- \"SFR.Period.Perc\"\n    }else if (input$radioKPI == 4){      \n      response.var <- \"SGR.Period.Perc\"\n    }else if (input$radioKPI == 5){      \n      response.var <- \"Mortality.Perc\"\n    }  \n  \n    # \"data\": dataset that based on the user choices in the first page\n    ds <- passData()  \n  \n    # Step 1: Create and find the best model\n    \n    # res.best.mod <- Find_Best_Model(ds, rate, response.var, predictors)\n    \n    # model that both predictors are non-linear\n    \n    predictors.vars <- c(\"Period.Av.Weight\", \"Avg.Temp\")\n    fmla <- as.formula( paste(response.var, \n                               paste(paste0(\"s(\",predictors.vars, \", bs= \\'cr\\' )\"), collapse=\"+\"), sep=\"~\") )\n    gam.mod <- gam(formula=fmla, family=gaussian(link=identity), data=ds)\n    \n    summary.gam.mod <-summary(gam.mod)\n    \n    pred.data <- data.frame(ds[,predictors.vars[1]], ds[,predictors.vars[2]])\n    colnames(pred.data) <- predictors.vars \n    pred.gam.mod <- predict(gam.mod, pred.data)\n    rmse.gam.mod <- sqrt( mean( (ds[, response.var] - pred.gam.mod)^2 ) )\n    \n    # Step 2: Create the KPI Table\n    #\n    # Create the Weight categories and Temperature values\n    minAvTemp <- max(10, round(min(ds$Avg.Temp)-1, digits=0) ) \n    maxAvTemp <- min(40, round(max(ds$Avg.Temp)+1, digits=0) ) \n    stepAvTemp <- input$temp.step\n    Temp.vals <- seq(from = minAvTemp, to = maxAvTemp, by= stepAvTemp)\n    \n    minAvWeight <- min(ds$Period.Av.Weight) \n    maxAvWeight <- max(ds$Period.Av.Weight) \n    step.WeightCat <- input$weight.step\n    AvWeight.vals <- seq(from = min(0,minAvWeight), to = maxAvWeight + step.WeightCat, by = step.WeightCat) \n\n    pred.table.values <- predict(gam.mod, newdata = expand.grid(\"Avg.Temp\" = Temp.vals, \n                                                                 \"Period.Av.Weight\" = AvWeight.vals))\n    \n    mat<-matrix(pred.table.values, nrow =length(Temp.vals), ncol= length(AvWeight.vals))\n    mat <- t(mat)\n   \n    colnames(mat) <- paste(Temp.vals, sep=\" \")\n    row.names(mat) <- paste(AvWeight.vals, sep=\" \")\n    \n    KPI.Table <- as.data.frame( cbind(\"AvWeightCat\"=AvWeight.vals, round(mat,3)) )\n    \n    if (input$radioKPI == 4){      \n      KPI.Table <- abs(KPI.Table)\n    }  \n    \n    return(KPI.Table)\n                               \n  })\n  \n  #------------------ KPI Table\n  output$KPI_Table <- renderTable({\n    \n    if (input$ViewKPITable == 0){\n      return() }\n    else{\n      isolate({\n              \n          KPI.Table <- estimateKPI.Table()\n          return(KPI.Table)\n      })\n    }\n    \n  })\n  \n  #------------------ 3D plot KPI Table\n  output$plot_3D_Table <- renderPlotly({ \n    \n    # if (input$goKPIAnalysis == 0){\n    #   return() }\n    # else{ \n    #   isolate({\n    #     \n            # inputs\n            KPI.Table <- estimateKPI.Table()\n            ds <- passData()\n           \n            predictors.vars <- c(\"Period.Av.Weight\", \"Avg.Temp\")\n            \n            if (input$radioKPI == 1){  \n              response.var <- \"Biol.FCR.Period\"\n            }else if (input$radioKPI == 2){  \n              response.var <- \"Econ.FCR.Period\"\n            }else if (input$radioKPI == 3){ \n              response.var <- \"SFR.Period.Perc\"\n            }else if (input$radioKPI == 4){      \n              response.var <- \"SGR.Period.Perc\"\n            }else if (input$radioKPI == 5){      \n              response.var <- \"Mortality.Perc\"\n            }\n            \n            dset <- ds[ , names(ds) %in% c(predictors.vars, response.var)] \n            \n            # KPIs table\n            nc <- ncol(KPI.Table)\n            nr <- nrow(KPI.Table)\n            # remove first column from table\n            table.data <- as.matrix(KPI.Table[,-1])\n            \n         #   RawData <- gather( table.data, predictors.vars[2], response.vars, 1:(nc-1) )\n        #    newRawData <- RawData %>% select(predictors.vars[2], predictors.vars[1], response.vars )\n            \n            f <- list(\n              family = \"Courier New, monospace\",\n              size = 14,\n              color = \"#7f7f7f\"\n            )\n            \n            # \"Avg.Temp\" axis (columns of KPI.Table)\n            ax1.names <- colnames(KPI.Table)\n            ax1.vals <- as.numeric(as.vector(ax1.names[2:nc]))\n            ax1.range = c( min(ax1.vals), max(ax1.vals) )\n            ax1.lab <- list(range=ax1.range, tickmode=\"array\",tickvals=ax1.vals, ticktext=as.character(ax1.vals), \n                          nticks = nc-1, showline=T, title = predictors.vars[2], titlefont = f) \n            \n            # \"Period.Av.Weight\" axis (rows of KPI.Table)\n            ax2.vals <- as.numeric(as.vector(KPI.Table[1:nr, 1]))\n            ax2.range = c( min(ax2.vals), max(ax2.vals) )\n            ax2.lab <- list(range=ax2.range, tickmode=\"array\",tickvals=ax2.vals, ticktext=as.character(ax2.vals), \n                          nticks = nr, showline=T, title = predictors.vars[1], titlefont = f)\n            \n            # Z = \"KPI\" axis\n            z.lab <- list(title = response.var, titlefont = f)\n            \n            scene=list(xaxis = ax2.lab, yaxis = ax1.lab, zaxis = z.lab)\n                       # camera = list(eye = list(x = 1.25, y = 1.25, z = 1.25)))\n            \n            # \n            fig.title <- paste(response.var, \"table per\", predictors.vars[1], \"and\", predictors.vars[2], sep=\" \")\n            p <- plot_ly(x=ax2.vals, y=ax1.vals, z = table.data, type = \"surface\") %>%\n                        layout(title = fig.title, scene=scene, width = 800, height = 600)\n                          # add_trace(data = dset, x = dset[, predictors.vars[1]], \n                          #           y = dset[, predictors.vars[2]], z = dset[, response.var],\n                          #           mode = \"markers\", type = \"scatter3d\",\n                          #           marker = list(size = 3, color = \"red\", symbol = 104)) %>% \n            \n            #p <- plot_ly(newRawData, x=~predictors.vars[2], y=~predictors.vars[1], \n            #             z = ~response.var, type = \"surface\") %>%\n            #              layout(title = fig.title, scene=scene, width = 800, height = 600) \n            \n         \n      #   })\n      # }    \n  })\n  \n  \n  #--------------------------------------------------------------------------------------------\n  #     Page \"About\" --- buzz words\n  #--------------------------------------------------------------------------------------------\n  output$plot.buzzWords <- renderPlot({\n    \n    terms <- c(\"Data Mining\", \"Machine Learning\", \"KDD\", \"Clustering\", \n                \"Classification\", \"Association Rules\", \"k-NN\", \"Random Forest\",\n                \"GAM\", \"GLM\", \"Regression\", \"Deep Learning\", \n                \"Neural Networks\", \"SVMs\", \"Descriptive Statistics\", \n                \"Predictive Analytics\", \"Statistical Learning\", \n                \"Outlier Detection\", \"Forecast\", \"Big Data\", \"Cloud\", \"Web\",\n                \"Aquaculture\", \"AquaManager\", \"AquaTracker\", \"Feeder\", \"SFR\", \"SGR\", \"Mortality\",  \n                \"Bass\", \"Bream\", \"Red Bream\", \"Meagre\", \"Hatchery\", \"FCR\", \"Temperature\",\n                \"Currents\", \"Harvest\", \"Site\", \"Cages\", \"Specie\", \"Batch\", \"Stocking\"\n              )\n    \n    Words <- rep(terms, 5)\n    Freqs <- round(runif(length(Words),0,1)*100 ,0)\n    df.words <- data.frame(Words, Freqs)\n    pal <- brewer.pal(8,\"Dark2\")\n    wordcloud(df.words$Words,df.words$Freqs, scale=c(3,2), min.freq=2, max.words=1000, \n              random.order=T, rot.per=.25, colors=pal, vfont=c(\"sans serif\",\"plain\"))\n    \n  })\n  \n}) # end shinyServer",
    "created" : 1472548927871.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2073220047",
    "id" : "8BC335DC",
    "lastKnownWriteTime" : 1476644767,
    "last_content_update" : 1476644767534,
    "path" : "D:/Windows_Workspace/R_projects/Project_DataMining_Aquaculture/Project_Galaxidi/DM_Aqua_Project_Periodic_Galaxidi/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}